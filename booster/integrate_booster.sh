#!/usr/bin/env bash

# This script is used to integrate the php-booster into your project (potentially DDEV)

# --- Configuration ---
BOOSTER_REPO_URL="https://github.com/TerrorSquad/php-booster.git"
BOOSTER_TARGET_DIR="php-booster"
BOOSTER_INTERNAL_PATH="${BOOSTER_TARGET_DIR}/booster"

# --- Local Development Mode ---
# Set BOOSTER_LOCAL_DEV=1 to use local booster directory instead of cloning from GitHub
# Set BOOSTER_LOCAL_PATH to specify the local booster directory path (default: ../booster)
BOOSTER_LOCAL_DEV="${BOOSTER_LOCAL_DEV:-0}"
BOOSTER_LOCAL_PATH="${BOOSTER_LOCAL_PATH:-../booster}"

# --- ANSI color codes ---
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

VERBOSE=false
NO_CLEANUP=false
IS_DDEV_PROJECT=0
INTERACTIVE_MODE=false
SKIP_INTERACTIVE=false

# Interactive mode configuration
INTERACTIVE_INSTALL_TOOLS=true
INTERACTIVE_TOOLS_SELECTED=()
INTERACTIVE_TICKET_PREFIX=""
INTERACTIVE_REQUIRE_TICKETS=false
INTERACTIVE_COMMIT_FOOTER_LABEL="Closes"

# Set the memory limit for Composer to unlimited (can help with large dependency trees)
export COMPOSER_MEMORY_LIMIT=-1

# Set Symfony recipe auto-acceptance to avoid interactive prompts during composer require/update
# This automatically accepts all recipes from both main and contrib repositories
export SYMFONY_FLEX_RECIPES_AUTO_ACCEPT=1

# --- Version Management ---

# Extract version from booster composer.json
function get_booster_version() {
    local booster_composer="${BOOSTER_INTERNAL_PATH}/composer.json"
    if [ -f "$booster_composer" ]; then
        jq -r '.version // "unknown"' "$booster_composer"
    else
        echo "unknown"
    fi
}

# Get the currently installed booster version
function get_installed_version() {
    local version_file=".booster-version"
    if [ -f "$version_file" ]; then
        grep "^VERSION=" "$version_file" 2>/dev/null | cut -d'=' -f2 || echo ""
    else
        echo ""
    fi
}

# Create or update the version stamp file
function create_version_stamp() {
    local version="$1"
    local version_file=".booster-version"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    cat > "$version_file" << EOF
# PHP Booster Version Stamp
# This file tracks which booster version was integrated into this project
# Generated by integrate_booster.sh

VERSION=$version
INSTALLED_DATE=$timestamp
INTEGRATION_METHOD=script
EOF

    log "Created version stamp: $version (installed $timestamp)"
}

# Show version information and upgrade status
function show_version_info() {
    local current_version="$1"
    local installed_version
    installed_version=$(get_installed_version)

    if [ -n "$installed_version" ]; then
        echo -e "${GREEN}[INFO]${NC} Previous booster installation detected: $installed_version"
        echo -e "${GREEN}[INFO]${NC} Current booster version: $current_version"

        if [ "$installed_version" != "$current_version" ]; then
            echo -e "${YELLOW}[UPGRADE]${NC} This will upgrade your booster from $installed_version to $current_version"
        else
            echo -e "${GREEN}[INFO]${NC} Re-integrating same version (idempotent operation)"
        fi
    else
        echo -e "${GREEN}[INFO]${NC} Installing PHP Booster version: $current_version"
    fi
}

# --- Helper Functions ---

function log() {
    if [ "$VERBOSE" = true ]; then
        echo -e "${NC}[LOG] $1${NC}"
    fi
}

function warn() {
    echo -e "${YELLOW}[WARN] $1${NC}"
}

function error() {
    echo -e "${RED}[ERROR] $1${NC}" >&2
    # Clean up before exiting on error
    cleanup_silent
    exit 1
}

function success() {
    echo -e "${GREEN}[SUCCESS] $1${NC}"
}

function info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

function prompt() {
    echo -e "${YELLOW}[?]${NC} $1"
}

# --- Interactive Mode Functions ---

function show_welcome_banner() {
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                                                                â•‘"
    echo "â•‘              ðŸš€ PHP Booster Interactive Setup ðŸš€               â•‘"
    echo "â•‘                                                                â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    info "Welcome! This wizard will help you configure PHP Booster for your project."
    echo ""
}

function confirm_action() {
    local message="$1"
    local default="${2:-n}"
    local response

    if [ "$default" = "y" ]; then
        prompt "$message [Y/n]: "
    else
        prompt "$message [y/N]: "
    fi

    read -r response
    response=${response:-$default}

    if [[ "$response" =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}

function select_tools_to_install() {
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    info "Step 1: Select Code Quality Tools"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "PHP Booster includes the following code quality tools:"
    echo ""
    echo "  1. ECS (EasyCodingStandard) - Automatic code formatting"
    echo "  2. Rector                   - Automated refactoring & PHP upgrades"
    echo "  3. PHPStan                  - Static analysis (bug detection)"
    echo "  4. Psalm                    - Additional static analysis"
    echo "  5. PHP Insights             - Advanced code quality metrics & architecture"
    echo ""

    local tools=("ecs" "rector" "phpstan" "psalm" "phpinsights")
    local tool_names=("ECS (EasyCodingStandard)" "Rector" "PHPStan" "Psalm" "PHP Insights")

    if confirm_action "Install all tools? (Recommended for new integrations)" "y"; then
        INTERACTIVE_TOOLS_SELECTED=("${tools[@]}")
        success "All tools selected for installation"
    else
        echo ""
        info "Select individual tools (you can add more later):"
        echo ""

        for i in "${!tools[@]}"; do
            if confirm_action "  Install ${tool_names[$i]}?" "y"; then
                INTERACTIVE_TOOLS_SELECTED+=("${tools[$i]}")
            fi
        done

        if [ ${#INTERACTIVE_TOOLS_SELECTED[@]} -eq 0 ]; then
            warn "No tools selected. Installing all tools as fallback."
            INTERACTIVE_TOOLS_SELECTED=("${tools[@]}")
        else
            success "Selected tools: ${INTERACTIVE_TOOLS_SELECTED[*]}"
        fi
    fi
}

function configure_git_workflow() {
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    info "Step 2: Configure Git Workflow"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "Git workflow features:"
    echo "  â€¢ Branch naming validation (e.g., feature/PRJ-123-my-feature)"
    echo "  â€¢ Conventional commit messages (e.g., feat:, fix:, chore:)"
    echo "  â€¢ Automatic ticket footer appending to commits"
    echo ""

    if confirm_action "Do you use ticket IDs in your branches? (e.g., JIRA, GitHub Issues)" "n"; then
        INTERACTIVE_REQUIRE_TICKETS=true
        echo ""
        prompt "Enter your ticket prefix (e.g., PRJ, JIRA, ISSUE): "
        read -r INTERACTIVE_TICKET_PREFIX

        if [ -z "$INTERACTIVE_TICKET_PREFIX" ]; then
            warn "No prefix provided. Using default: 'TICKET'"
            INTERACTIVE_TICKET_PREFIX="TICKET"
        fi

        success "Ticket prefix set to: $INTERACTIVE_TICKET_PREFIX"

        echo ""
        prompt "Enter the commit footer label (default: Closes): "
        read -r footer_label

        if [ -n "$footer_label" ]; then
            INTERACTIVE_COMMIT_FOOTER_LABEL="$footer_label"
        fi

        success "Commit footer will be: $INTERACTIVE_COMMIT_FOOTER_LABEL: $INTERACTIVE_TICKET_PREFIX-XXX"
    else
        INTERACTIVE_REQUIRE_TICKETS=false
        info "Ticket IDs will be optional in branch names"
    fi
}

function configure_ide_settings() {
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    info "Step 3: IDE Configuration"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "PHP Booster includes IDE settings for:"
    echo "  â€¢ VS Code (.vscode/)"
    echo "  â€¢ PhpStorm (.phpstorm/)"
    echo "  â€¢ EditorConfig (.editorconfig)"
    echo ""

    if confirm_action "Install IDE configuration files?" "y"; then
        success "IDE settings will be installed"
        return 0
    else
        warn "Skipping IDE configuration (you can add them manually later)"
        return 1
    fi
}

function show_configuration_summary() {
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    info "Configuration Summary"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    echo "ðŸ“¦ Tools to install:"
    for tool in "${INTERACTIVE_TOOLS_SELECTED[@]}"; do
        echo "   âœ“ $tool"
    done
    echo ""

    echo "ðŸ”§ Git Workflow:"
    if [ "$INTERACTIVE_REQUIRE_TICKETS" = true ]; then
        echo "   âœ“ Ticket IDs: Required"
        echo "   âœ“ Ticket Prefix: $INTERACTIVE_TICKET_PREFIX"
        echo "   âœ“ Commit Footer: $INTERACTIVE_COMMIT_FOOTER_LABEL"
    else
        echo "   âœ“ Ticket IDs: Optional"
    fi
    echo ""

    echo "ðŸŽ¨ IDE Settings: Will be installed"
    echo ""

    if ! confirm_action "Proceed with this configuration?" "y"; then
        error "Installation cancelled by user"
    fi

    echo ""
    success "Configuration confirmed. Starting integration..."
    sleep 1
}

function apply_interactive_configuration() {
    # Update branch validation config with user's choices
    if [ "$INTERACTIVE_REQUIRE_TICKETS" = true ] && [ -n "$INTERACTIVE_TICKET_PREFIX" ]; then
        local config_file="validate-branch-name.config.cjs"

        if [ -f "$config_file" ]; then
            log "Updating branch validation config with ticket prefix: $INTERACTIVE_TICKET_PREFIX"

            # Update ticket prefix
            sed -i.bak "s/ticketIdPrefix: '[^']*'/ticketIdPrefix: '$INTERACTIVE_TICKET_PREFIX'/g" "$config_file"

            # Update requireTickets flag
            sed -i.bak "s/requireTickets: false/requireTickets: true/g" "$config_file"

            # Update commit footer label
            sed -i.bak "s/commitFooterLabel: '[^']*'/commitFooterLabel: '$INTERACTIVE_COMMIT_FOOTER_LABEL'/g" "$config_file"

            rm -f "$config_file.bak"

            success "Branch validation configured with your settings"
        fi
    fi
}

function show_post_installation_summary() {
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                                                                â•‘"
    echo "â•‘              âœ… PHP Booster Setup Complete! âœ…                 â•‘"
    echo "â•‘                                                                â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "ðŸ“‹ Next Steps:"
    echo ""
    echo "1. Review the integrated files:"
    echo "   â€¢ validate-branch-name.config.cjs  - Branch naming rules"
    echo "   â€¢ commitlint.config.ts             - Commit message rules"
    echo "   â€¢ ecs.php, rector.php, phpstan.neon.dist - Code quality configs"
    echo "   â€¢ phpinsights.php                  - PHP Insights configuration"
    echo ""
    echo "2. Try the available commands:"

    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        echo "   ddev composer ecs          # Check/fix code style"
        echo "   ddev composer rector       # Apply automated refactoring"
        echo "   ddev composer phpstan      # Run static analysis"
        echo "   ddev composer psalm        # Additional static analysis"
        echo "   ddev composer phpinsights  # Run PHP Insights analysis"
    else
        echo "   composer ecs               # Check/fix code style"
        echo "   composer rector            # Apply automated refactoring"
        echo "   composer phpstan           # Run static analysis"
        echo "   composer psalm             # Additional static analysis"
        echo "   composer phpinsights       # Run PHP Insights analysis"
    fi

    echo ""
    echo "3. Test your Git hooks:"
    echo "   â€¢ Create a test branch with proper naming"

    if [ "$INTERACTIVE_REQUIRE_TICKETS" = true ]; then
        echo "     Example: git checkout -b feature/$INTERACTIVE_TICKET_PREFIX-123-test-booster"
    else
        echo "     Example: git checkout -b feature/test-booster"
    fi

    echo "   â€¢ Make a commit with conventional format"
    echo "     Example: git commit -m \"feat: add PHP Booster integration\""
    echo ""
    echo "4. Commit the booster integration:"
    echo "   git add ."
    echo "   git commit -m \"chore: integrate PHP Booster tooling\""
    echo ""
    echo "ðŸ“š Documentation: https://terrorsquad.github.io/php-booster/"
    echo ""

    if [ "$INTERACTIVE_REQUIRE_TICKETS" = true ]; then
        echo "ðŸ’¡ Tip: Your commit messages will automatically include:"
        echo "   $INTERACTIVE_COMMIT_FOOTER_LABEL: $INTERACTIVE_TICKET_PREFIX-XXX"
        echo ""
    fi

    success "Happy coding with PHP Booster! ðŸš€"
    echo ""
}

function run_interactive_mode() {
    show_welcome_banner
    select_tools_to_install
    configure_git_workflow
    configure_ide_settings
    show_configuration_summary
}

# --- Dependency Checks ---

function check_dependencies() {
    log "Checking dependencies..."
    local missing_deps=()
    command -v jq >/dev/null 2>&1 || missing_deps+=("jq")
    command -v yq >/dev/null 2>&1 || missing_deps+=("yq") # Still needed for ddev config
    command -v curl >/dev/null 2>&1 || missing_deps+=("curl")
    command -v unzip >/dev/null 2>&1 || missing_deps+=("unzip")

    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        command -v ddev >/dev/null 2>&1 || missing_deps+=("ddev")
    else
        command -v composer >/dev/null 2>&1 || missing_deps+=("composer")
        command -v pnpm >/dev/null 2>&1 || missing_deps+=("pnpm")
    fi

    if [ ${#missing_deps[@]} -ne 0 ]; then
        error "Missing dependencies: ${missing_deps[*]}. Please install them."
    fi
    success "All dependencies are satisfied."
}

# --- Project Type Detection ---

function is_ddev_project() {
    if [ -d ".ddev" ]; then
        echo 1
    else
        echo 0
    fi
}

# --- Core Logic Functions ---

function download_php_booster() {
    if [ "$BOOSTER_LOCAL_DEV" = "1" ]; then
        log "Using local php-booster for development..."
        # Clean up previous attempts first
        rm -rf "$BOOSTER_TARGET_DIR" # Remove target dir if it exists

        # Check if local booster path exists
        if [ ! -d "$BOOSTER_LOCAL_PATH" ]; then
            error "Local booster directory not found at '$BOOSTER_LOCAL_PATH'. Set BOOSTER_LOCAL_PATH or ensure the directory exists."
        fi

        # Copy the local booster instead of cloning
        mkdir -p "$BOOSTER_TARGET_DIR"
        cp -R "$BOOSTER_LOCAL_PATH" "$BOOSTER_INTERNAL_PATH" || error "Failed to copy local booster directory."

        if [ ! -d "$BOOSTER_INTERNAL_PATH" ]; then
            error "Target directory '$BOOSTER_INTERNAL_PATH' not found after copy."
        fi

        success "Local php-booster copied successfully from '$BOOSTER_LOCAL_PATH'."
    else
        log "Cloning php-booster from $BOOSTER_REPO_URL..."
        # Clean up previous attempts first
        rm -rf "$BOOSTER_TARGET_DIR" # Remove target dir if it exists

        # Clone only the main branch and only the latest commit for speed
        git clone --depth 1 --branch main "$BOOSTER_REPO_URL" "$BOOSTER_TARGET_DIR" || error "Failed to clone booster repository."

        if [ ! -d "$BOOSTER_TARGET_DIR" ]; then
            error "Target directory '$BOOSTER_TARGET_DIR' not found after clone."
        fi

        if [ ! -d "$BOOSTER_INTERNAL_PATH" ]; then
            warn "The expected internal structure '$BOOSTER_INTERNAL_PATH' was not found within the cloned repository."
            error "Booster content directory '$BOOSTER_INTERNAL_PATH' not found."
        fi
        success "php-booster cloned successfully into '$BOOSTER_TARGET_DIR'."
    fi
}

function update_ddev_files() {
    log "Updating ddev files..."
    local booster_ddev_path="${BOOSTER_INTERNAL_PATH}/.ddev"
    local project_ddev_path=".ddev"

    if [ ! -d "$booster_ddev_path" ]; then
        warn "Booster DDEV directory '$booster_ddev_path' not found. Skipping DDEV file update."
        return
    fi

    # Define source -> destination mappings relative to .ddev dirs
    local ddev_subdirs=("commands" "php" "web-build")
    for subdir in "${ddev_subdirs[@]}"; do
        local src_path="${booster_ddev_path}/${subdir}"
        local dest_path="${project_ddev_path}/${subdir}"
        if [ -d "$src_path" ]; then
            log "  Copying '$src_path' to '$dest_path'..."
            # Use standard recursive copy -R, ensure destination parent exists
            mkdir -p "$dest_path"
            # Copy the source directory *into* the destination directory
            cp -R $src_path/. "$dest_path" || warn "Failed to copy '$src_path'. Check permissions."
        else
            log "  Booster DDEV subdirectory '$subdir' not found at '$src_path'. Skipping."
        fi
    done
    success "ddev files updated."
}

function update_ddev_config() {
    log "Updating ddev config using yq..."
    local project_config=".ddev/config.yaml"
    local booster_config="${BOOSTER_INTERNAL_PATH}/.ddev/config.yaml"
    local hooks_tmp="hooks.yaml.tmp"
    local merged_tmp=".ddev/config.yaml.tmp"

    if [ ! -f "$project_config" ]; then
        warn "Project DDEV config '$project_config' not found. Skipping update."
        return
    fi
    if [ ! -f "$booster_config" ]; then
        warn "Booster DDEV config '$booster_config' not found. Skipping update."
        return
    fi

    # 1. Extract hooks from booster config (handle potential errors)
    log "  Extracting hooks from booster config..."
    if ! yq '.hooks' "$booster_config" >"$hooks_tmp"; then
        warn "Failed to extract hooks using yq from '$booster_config'. Skipping hook merge."
        rm -f "$hooks_tmp"
    else
        # 2. Merge hooks into project config
        log "  Merging hooks into project config..."
        if ! yq eval-all 'select(fileIndex == 0) * {"hooks": select(fileIndex == 1)}' "$project_config" "$hooks_tmp" >"$merged_tmp"; then
            warn "Failed to merge hooks using yq. Original config preserved."
            rm -f "$hooks_tmp" "$merged_tmp"
            return # Stop ddev config update here if merge fails
        else
            # Replace project config with merged one if successful
            mv "$merged_tmp" "$project_config"
            log "  Hooks merged successfully."
        fi
        rm -f "$hooks_tmp"
    fi

    # 3. Ensure xdebug_enabled is true (operate on the potentially updated project_config)
    log "  Ensuring 'xdebug_enabled = true' using yq..."
    if ! yq eval '.xdebug_enabled = true' -i "$project_config"; then
        warn "Failed to set 'xdebug_enabled = true' using yq. Check '$project_config'."
    fi

    # 4. Copy nodejs_version key from booster config
    log "  Copying 'nodejs_version' from booster config..."
    nodejs_version=$(yq eval '.nodejs_version' "$booster_config")
    if ! yq eval ".nodejs_version = \"$nodejs_version\"" -i "$project_config"; then
        warn "Failed to copy 'nodejs_version' from booster config. Check '$project_config'."
    fi

    # 5. Ensure corepack_enable is true
    if ! yq eval '.corepack_enable = true' -i "$project_config"; then
        warn "Failed to set 'corepack_enable = true' using yq. Check '$project_config'."
    fi

    success "ddev config updated. Ensure the paths in the config are correct."
}

function copy_files() {
    log "Copying common files (excluding internal test helpers)..."

    # Copy simple top-level directories wholesale
    local top_level=(".github" ".vscode" ".phpstorm" ".editorconfig")
    for item in "${top_level[@]}"; do
        local src_path="${BOOSTER_INTERNAL_PATH}/${item}"
        if [ -e "$src_path" ]; then
            log "  Copying '$src_path' -> '$item'"
            cp -R "$src_path" . || warn "Failed to copy '$src_path'."
        else
            log "  Missing optional item '$item', skipping."
        fi
    done

    # Copy selected tool scripts instead of entire tools directory
    local tools_src="${BOOSTER_INTERNAL_PATH}/tools"
    if [ -d "$tools_src" ]; then
        mkdir -p tools/git-hooks

        # Copy git-hooks/hooks directory
        if [ -d "$tools_src/git-hooks/hooks" ]; then
            log "  Copying git-hooks/hooks directory"
            cp -R "$tools_src/git-hooks/hooks" tools/git-hooks/
            # Set execute permissions for all scripts in hooks directory
            find "tools/git-hooks/hooks" -type f \( -name "*.sh" -o -name "*.bash" -o -name "*.mjs" \) -exec chmod +x {} \;
        else
            warn "  Expected tool directory missing: git-hooks/hooks"
        fi

        # Copy git-hooks/shared directory
        if [ -d "$tools_src/git-hooks/shared" ]; then
            log "  Copying git-hooks/shared directory"
            cp -R "$tools_src/git-hooks/shared" tools/git-hooks/
            # Set execute permissions for scripts in shared directory
            find "tools/git-hooks/shared" -type f \( -name "*.sh" -o -name "*.bash" -o -name "*.mjs" \) -exec chmod +x {} \;
        else
            warn "  Expected tool directory missing: git-hooks/shared"
        fi
    else
        warn "  Booster tools directory not found; skipping tools copy."
    fi

    # Copy validate-branch-name config (needed by hooks & scripts)
    local branch_cfg="${BOOSTER_INTERNAL_PATH}/validate-branch-name.config.cjs"
    if [ -f "$branch_cfg" ]; then
        cp "$branch_cfg" . || warn "Failed to copy validate-branch-name.config.cjs"
    else
        warn "validate-branch-name.config.cjs missing in booster."
    fi

    success "Common files copied (tools filtered to runtime essentials)."
}

function update_package_json() {
    log "Updating package.json..."
    local project_pkg="package.json"
    local booster_pkg="${BOOSTER_INTERNAL_PATH}/package.json"
    local booster_commitlint="${BOOSTER_INTERNAL_PATH}/commitlint.config.ts"
    local tmp_pkg="package.json.tmp"

    if [ ! -f "$booster_pkg" ]; then
        warn "Booster package.json '$booster_pkg' not found. Skipping update."
        return
    fi

    if [ ! -f "$project_pkg" ]; then
        log "'$project_pkg' not found. Copying from booster..."
        cp "$booster_pkg" "$project_pkg" || error "Failed to copy booster package.json."
        success "package.json copied from booster."
    else
        log "'$project_pkg' already exists. Merging scripts, devDependencies, and sections..."
        # Merge using jq: project + booster (booster overwrites simple keys, merges objects)
        # This merges top-level objects like scripts, devDependencies
        jq -s '
            .[0] as $proj | .[1] as $booster |
            $proj * {
                scripts: (($proj.scripts // {}) + ($booster.scripts // {})),
                devDependencies: (($proj.devDependencies // {}) + ($booster.devDependencies // {})),
                husky: (($proj.husky // {}) + ($booster.husky // {})),
                packageManager: $booster.packageManager
            }
            ' "$project_pkg" "$booster_pkg" >"$tmp_pkg" || error "Failed to merge package.json using jq."

        mv "$tmp_pkg" "$project_pkg"
        success "package.json updated with merged scripts and devDependencies."
    fi

    # Copy commitlint config regardless
    if [ -f "$booster_commitlint" ]; then
        cp "$booster_commitlint" . || warn "Failed to copy commitlint config."
        success "commitlint.config.ts copied."
    else
        warn "Booster 'commitlint.config.ts' not found. Skipping copy."
    fi

    # Copy pnpm-workspace.yaml if it exists
    local booster_pnpm_workspace="${BOOSTER_INTERNAL_PATH}/pnpm-workspace.yaml"
    if [ -f "$booster_pnpm_workspace" ]; then
        cp "$booster_pnpm_workspace" . || warn "Failed to copy pnpm-workspace.yaml."
        success "pnpm-workspace.yaml copied."
    else
        warn "Booster 'pnpm-workspace.yaml' not found. Skipping copy."
    fi
}

# --- Updated merge_scripts Function ---
function merge_scripts() {
    local COMPOSER1="composer.json"                          # Project composer.json
    local COMPOSER2="${BOOSTER_INTERNAL_PATH}/composer.json" # Booster composer.json
    local OUTPUT="composer.json.merged.tmp"

    # Ensure jq is available
    command -v jq >/dev/null 2>&1 || error "jq is required but not installed."

    # Check if files exist
    [ ! -f "$COMPOSER1" ] && error "Project composer.json not found at '$COMPOSER1'"
    [ ! -f "$COMPOSER2" ] && error "Booster composer.json not found at '$COMPOSER2'"

    log "Merging scripts from '$COMPOSER2' into '$COMPOSER1'..."

    # Create a temporary copy to work on
    cp "$COMPOSER1" "$OUTPUT"

    # Get script keys from booster composer.json, handle null/missing scripts section
    # Use jq -e to check exit status if .scripts is null or not an object
    if ! jq -e '(.scripts // {}) | type == "object"' "$COMPOSER2" >/dev/null; then
        log "No valid 'scripts' object found in booster composer.json. Nothing to merge."
        rm "$OUTPUT" # Clean up temp file
        return 0
    fi
    local booster_keys
    booster_keys=$(jq -r '.scripts | keys_unsorted | .[]' "$COMPOSER2")

    # Iterate over each script key from the booster
    echo "$booster_keys" | while IFS= read -r key; do
        log "  Processing script key: $key"

        # Get values and types using jq
    local proj_script_json
    proj_script_json=$(jq --arg key "$key" '(.scripts // {})[$key]' "$OUTPUT")
    local booster_script_json
    booster_script_json=$(jq --arg key "$key" '.scripts[$key]' "$COMPOSER2") # Assumes .scripts exists from check above
    local proj_type
    proj_type=$(jq -r 'type' <<<"$proj_script_json")
    local booster_type
    booster_type=$(jq -r 'type' <<<"$booster_script_json")

        log "    Project type: $proj_type, Booster type: $booster_type"

        local merged_script_json

        if [ "$proj_type" == "null" ]; then
            # Script only exists in booster, add it
            log "    Adding script from booster."
            merged_script_json="$booster_script_json"
        else
            # Script exists in both project and booster, merge based on type
            if [ "$proj_type" == "string" ] && [ "$booster_type" == "string" ]; then
                if [ "$proj_script_json" == "$booster_script_json" ]; then
                    log "    Scripts are identical strings, keeping project version."
                    merged_script_json="$proj_script_json"
                else
                    log "    Scripts are different strings, merging into unique array."
                    # Ensure output is valid JSON array
                    merged_script_json=$(jq -n --argjson p "$proj_script_json" --argjson b "$booster_script_json" '[$p, $b] | unique')
                fi
            elif [ "$proj_type" == "array" ] && [ "$booster_type" == "array" ]; then
                log "    Both scripts are arrays, merging uniquely."
                merged_script_json=$(jq -n --argjson p "$proj_script_json" --argjson b "$booster_script_json" '($p + $b) | unique')
            elif [ "$proj_type" == "string" ] && [ "$booster_type" == "array" ]; then
                log "    Project is string, booster is array. Merging uniquely."
                merged_script_json=$(jq -n --argjson p "$proj_script_json" --argjson b "$booster_script_json" '([$p] + $b) | unique')
            elif [ "$proj_type" == "array" ] && [ "$booster_type" == "string" ]; then
                log "    Project is array, booster is string. Merging uniquely."
                merged_script_json=$(jq -n --argjson p "$proj_script_json" --argjson b "$booster_script_json" '($p + [$b]) | unique')
            else
                # Handle other mismatches (e.g., object vs string) - prefer booster? Or keep project? Let's prefer booster.
                log "    Type mismatch ($proj_type vs $booster_type). Using booster version."
                merged_script_json="$booster_script_json"
            fi
        fi

        # Update the temporary composer file with the merged script
        # Ensure .scripts object exists before assigning
        local temp_next="$OUTPUT.next"
        jq --arg key "$key" --argjson value "$merged_script_json" \
            'if (.scripts | type) != "object" then .scripts = {} else . end | .scripts[$key] = $value' \
            "$OUTPUT" >"$temp_next" || {
            error "jq update failed for key '$key'"
            rm "$temp_next" "$OUTPUT"
            return 1
        } # Exit loop on jq error
        mv "$temp_next" "$OUTPUT"

    done || error "Failed during script merging loop." # Catch errors from the while loop subshell

    # Replace the original composer.json with the merged version
    mv "$OUTPUT" "$COMPOSER1"
    success "Scripts merged idempotently into $COMPOSER1."
}
# --- Function to Update Tool Paths Dynamically ---
function update_tool_paths() {
    # --- Copy Documentation Directory ---
    local booster_doc_path="${BOOSTER_INTERNAL_PATH}/documentation"
    if [ -d "$booster_doc_path" ]; then
        log "  Copying '$booster_doc_path' to 'documentation'..."
        # Use standard recursive copy -R
        cp -R "$booster_doc_path/." "documentation" || warn "Failed to copy documentation directory."
    else
        log "  Booster documentation directory not found. Skipping."
    fi

    # --- Copy Config Files ---
    local cq_files=("rector.php" "phpstan.neon.dist" "ecs.php" "psalm.xml" "phpinsights.php")
    for file in "${cq_files[@]}"; do
        local src_path="${BOOSTER_INTERNAL_PATH}/${file}"
        if [ -f "$src_path" ]; then
            cp "$src_path" . || warn "Failed to copy '$src_path'."
        else
            log "  Booster config '$file' not found. Skipping."
        fi
    done

    success "Code quality tool configs and documentation copied."

    log "Dynamically updating paths in tool configuration files using temp files and sed..."
    local php_dirs_file="php_dirs.txt"
    local return_code=0 # Track overall success/failure

    # 1. Find directories containing .php files and save to php_dirs.txt
    log "  Searching for directories containing PHP files (excluding vendor, .git, node_modules, etc.)..."
    find . -type f \
        -name "*.php" \
        -not -path "./vendor/*" \
        -not -path "./node_modules/*" \
        -not -path "./php-booster/*" \
        -not -path "./.ddev/*" \
        -exec dirname {} \; | sort -u | grep -v ^.$ | cut -d '/' -f2 | sort -u >"$php_dirs_file" || {
        warn "find command failed or produced unexpected output while searching for PHP directories."
        # Create empty file if find failed, to avoid errors later
        touch "$php_dirs_file"
    }

    if [ ! -s "$php_dirs_file" ]; then
        warn "No subdirectories containing PHP files found (excluding vendor, hidden dirs, etc.). Placeholders will be removed from tool configurations."
    else
        log "  Found PHP directories listed in '$php_dirs_file'."
    fi

    # --- Define helper for sed replacement ---
    # Usage: replace_placeholder "config_file" "placeholder_regex" "formatted_dirs_file"
    function replace_placeholder() {
        local config_file="$1"
        local placeholder_regex="$2"
        local formatted_dirs_file="$3"
        local tmp_config_file="${config_file}.tmp"

        if [ ! -f "$config_file" ]; then
            log "    File '$config_file' not found. Skipping."
            return 0
        fi

        log "    Processing '$config_file'..."
        # Use process substitution <(...) if available and preferred, otherwise use temp file
        # Using temp file for broader compatibility

        # Create the new file by reading the formatted dirs where the placeholder is found
        # Use -n to suppress default output, p to print non-matching lines, r to read on match
        # This requires two passes or complex scripting. Let's use the requested r/d approach.

        # Pass 1: Read the formatted dirs file after the placeholder line
        sed -e "$placeholder_regex r $formatted_dirs_file" "$config_file" >"$tmp_config_file" || {
            warn "sed 'r' command failed for '$config_file'."
            rm -f "$tmp_config_file"
            return 1
        }

        # Pass 2: Delete the placeholder line from the temp file, overwrite original
        sed -i.bak -e "$placeholder_regex d" "$tmp_config_file" || {
            warn "sed 'd' command failed for '$tmp_config_file'."
            rm -f "$tmp_config_file"
            # Restore original from backup if it exists
            [ -f "${config_file}.bak" ] && mv "${config_file}.bak" "$config_file"
            return 1
        }

        mv "$tmp_config_file" "$config_file"
        rm -f $config_file.tmp.bak

        return 0
    }

    # --- Process Rector PHP file ---
    local rector_file="rector.php"
    local rector_dirs_file="rector_dirs.txt"
    local rector_placeholder_regex="/^[[:space:]]*__DIR__ \. '\/DIRECTORY',[[:space:]]*$/"
    # Create formatted dirs file
    rm -f "$rector_dirs_file" && touch "$rector_dirs_file"
    if [ -s "$php_dirs_file" ]; then # Only loop if dirs were found
        while IFS= read -r dir; do
            printf "        __DIR__ . '/%s',\n" "$dir" >>"$rector_dirs_file"
        done <"$php_dirs_file"
    fi

    replace_placeholder "$rector_file" "$rector_placeholder_regex" "$rector_dirs_file" || return_code=1
    rm -f "$rector_dirs_file" # Clean up

    # --- Process ECS PHP file ---
    local ecs_file="ecs.php"
    local ecs_dirs_file="ecs_dirs.txt"
    local ecs_placeholder_regex="/^[[:space:]]*__DIR__ \. '\/DIRECTORY',[[:space:]]*$/"

    rm -f "$ecs_dirs_file" && touch "$ecs_dirs_file"
    if [ -s "$php_dirs_file" ]; then
        while IFS= read -r dir; do
            printf "        __DIR__ . '/%s',\n" "$dir" >>"$ecs_dirs_file"
        done <"$php_dirs_file"
    fi

    replace_placeholder "$ecs_file" "$ecs_placeholder_regex" "$ecs_dirs_file" || return_code=1
    rm -f "$ecs_dirs_file" # Clean up

    # --- Process Psalm XML file ---
    local psalm_file="psalm.xml"
    local psalm_dirs_file="psalm_dirs.txt"
    local psalm_placeholder_regex='/^[[:space:]]*<directory name="DIRECTORY" \/>[[:space:]]*$/'

    rm -f "$psalm_dirs_file" && touch "$psalm_dirs_file"
    if [ -s "$php_dirs_file" ]; then
        while IFS= read -r dir; do
            # Basic XML escaping for dir name (only & and < are strictly needed here, but > and " are good practice)
            local escaped_dir
            escaped_dir=$(echo "$dir" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g' -e 's/"/\&quot;/g')
            printf '        <directory name="%s" />\n' "$escaped_dir" >>"$psalm_dirs_file"
        done <"$php_dirs_file"
    fi

    replace_placeholder "$psalm_file" "$psalm_placeholder_regex" "$psalm_dirs_file" || return_code=1
    rm -f "$psalm_dirs_file" # Clean up

    # --- Process PHPStan NEON file ---
    local phpstan_file="phpstan.neon.dist"
    local phpstan_dirs_file="phpstan_dirs.txt"
    local phpstan_placeholder_regex='/^[[:space:]]*-[[:space:]]*DIRECTORY[[:space:]]*$/'

    rm -f "$phpstan_dirs_file" && touch "$phpstan_dirs_file"
    if [ -s "$php_dirs_file" ]; then
        while IFS= read -r dir; do
            printf '    - %s\n' "$dir" >>"$phpstan_dirs_file"
        done <"$php_dirs_file"
    fi

    replace_placeholder "$phpstan_file" "$phpstan_placeholder_regex" "$phpstan_dirs_file" || return_code=1
    rm -f "$phpstan_dirs_file" # Clean up

    # --- Final Cleanup and Status ---
    rm -f "$php_dirs_file"

    if [ $return_code -eq 0 ]; then
        success "Tool configuration paths updated dynamically based on found PHP directories."
        return 0
    else
        warn "Errors occurred while updating tool configuration paths. Check logs."
        return 1
    fi
}

function add_code_quality_tools() {
    log "Adding code quality tools..."
    local project_composer="composer.json"
    local booster_composer="${BOOSTER_INTERNAL_PATH}/composer.json"

    # --- Update composer.json ---
    log "Updating composer.json..."
    if [ ! -f "$project_composer" ]; then
        warn "'$project_composer' not found. Cannot merge scripts or add dependencies. Consider copying booster composer.json first."
        return
    fi
    if [ ! -f "$booster_composer" ]; then
        warn "Booster composer.json '$booster_composer' not found. Skipping composer update."
        return
    fi

    merge_scripts

    # --- Install Composer Dependencies ---
    local composer_cmd
    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        composer_cmd=(ddev composer)
    else
        composer_cmd=(composer)
    fi

    # Helper function to check if a package is already declared in composer.json
    function is_package_present() {
        local package="$1"
        local section="$2"  # "require" or "require-dev"

        log "    Checking if package '$package' is present in section '$section'..."

        # Check if package is declared in the appropriate section of composer.json
        if [ "$section" = "require" ]; then
            if jq -e --arg pkg "$package" '.require[$pkg] != null' "$project_composer" >/dev/null 2>&1; then
                log "    Package '$package' found in require section."
                return 0
            else
                log "    Package '$package' NOT found in require section."
                return 1
            fi
        elif [ "$section" = "require-dev" ]; then
            if jq -e --arg pkg "$package" '.["require-dev"][$pkg] != null' "$project_composer" >/dev/null 2>&1; then
                log "    Package '$package' found in require-dev section."
                return 0
            else
                log "    Package '$package' NOT found in require-dev section."
                return 1
            fi
        else
            # If no section specified, check both require and require-dev
            if jq -e --arg pkg "$package" '(.require[$pkg] != null) or (.["require-dev"][$pkg] != null)' "$project_composer" >/dev/null 2>&1; then
                log "    Package '$package' found in either require or require-dev section."
                return 0
            else
                log "    Package '$package' NOT found in either section."
                return 1
            fi
        fi
    }

    # Process production dependencies
    if jq -e '.require | type == "object"' "$booster_composer" >/dev/null; then
    local prod_deps
    prod_deps=$(jq -r '.require | keys_unsorted | .[]' "$booster_composer")
        local missing_prod_deps=()

        if [ -n "$prod_deps" ]; then
            log "Checking production dependencies..."
            while IFS= read -r dep; do
                if ! is_package_present "$dep" "require"; then
                    log "  Missing production dependency: $dep"
                    missing_prod_deps+=("$dep")
                else
                    log "  Production dependency already present: $dep"
                fi
            done <<<"$prod_deps"

            if [ ${#missing_prod_deps[@]} -gt 0 ]; then
                log "Adding missing composer 'require' dependencies from booster..."

                # Install packages individually for better error handling
                local failed_prod_packages=()

                for dep in "${missing_prod_deps[@]}"; do
                    log "Installing production dependency: $dep"
                    if "${composer_cmd[@]}" require --no-scripts "$dep"; then
                        success "Successfully installed: $dep"
                    else
                        error "Failed to install critical production dependency: $dep"
                        failed_prod_packages+=("$dep")
                    fi
                done

                if [ ${#failed_prod_packages[@]} -gt 0 ]; then
                    error "Critical production dependencies failed to install: ${failed_prod_packages[*]}"
                    return 1
                fi
            else
                log "All production dependencies are already present."
            fi
        else
            log "No production dependencies found in booster composer.json 'require' section."
        fi
    else
        log "No 'require' object found in booster composer.json."
    fi

    # Process development dependencies
    if jq -e '.["require-dev"] | type == "object"' "$booster_composer" >/dev/null; then
    local dev_deps
    dev_deps=$(jq -r '.["require-dev"] | keys_unsorted | .[]' "$booster_composer")
        local missing_dev_deps=()

        log "Booster require-dev packages found: $(echo "$dev_deps" | tr '\n' ' ')"

        if [ -n "$dev_deps" ]; then
            log "Checking development dependencies..."
            while IFS= read -r dep; do
                if ! is_package_present "$dep" "require-dev"; then
                    log "  Missing dev dependency: $dep"
                    missing_dev_deps+=("$dep")
                else
                    log "  Dev dependency already present: $dep"
                fi
            done <<<"$dev_deps"

            log "Missing dev dependencies to install: ${missing_dev_deps[*]}"

            if [ ${#missing_dev_deps[@]} -gt 0 ]; then
                log "Adding missing composer 'require-dev' dependencies from booster..."

                # Install packages individually for better error handling
                local failed_packages=()
                local critical_packages=("rector/rector" "phpstan/phpstan" "symplify/easy-coding-standard")

                for dep in "${missing_dev_deps[@]}"; do
                    log "Installing dev dependency: $dep"
                    if "${composer_cmd[@]}" require --dev "$dep"; then
                        success "Successfully installed: $dep"
                    else
                        warn "Failed to install: $dep"
                        failed_packages+=("$dep")

                        # Check if this is a critical package
                        if [[ " ${critical_packages[*]} " =~ " ${dep} " ]]; then
                            error "Critical package '$dep' failed to install. Integration cannot continue."
                            return 1
                        fi
                    fi
                done

                if [ ${#failed_packages[@]} -gt 0 ]; then
                    warn "Some non-critical packages failed to install: ${failed_packages[*]}"
                    warn "Integration will continue, but some tools may not be available."
                else
                    success "All development dependencies installed successfully."
                fi
            else
                log "All development dependencies are already present."
            fi
        else
            log "No development dependencies found in booster composer.json 'require-dev' section."
        fi
    else
        log "No 'require-dev' object found in booster composer.json."
    fi

    success "composer.json updated with merged scripts and new dependencies."
}

function update_readme() {
    log "Updating README.md..."
    local project_readme="README.md"
    local booster_snippet="${BOOSTER_INTERNAL_PATH}/README_SNIPPET.md"

    if [ -f "$project_readme" ]; then
        log "'$project_readme' already exists. Skipping creation."
    else
        if [ -f "$booster_snippet" ]; then
            warn "'$project_readme' not found. Creating new README.md from booster snippet..."
            cp "$booster_snippet" "$project_readme" || error "Failed to copy README snippet."
            success "New README.md created with content from '$booster_snippet'."
        else
            warn "'$project_readme' not found, and booster snippet '$booster_snippet' also not found. Skipping."
        fi
    fi
}

function update_gitignore() {
    log "Updating .gitignore..."
    local project_gitignore=".gitignore"
    local booster_gitignore="${BOOSTER_INTERNAL_PATH}/.gitignore"

    if [ ! -f "$booster_gitignore" ]; then
        warn "Booster .gitignore '$booster_gitignore' not found. Skipping update."
        return
    fi

    touch "$project_gitignore"

    # Remove .vscode entries from project gitignore since booster provides IDE settings
    log "Removing .vscode entries from project .gitignore..."
    local temp_gitignore="${project_gitignore}.tmp"

    # Remove lines that ignore .vscode (with or without leading slash, with or without trailing slash)
    grep -v -E '^[[:space:]]*/?\.vscode/?[[:space:]]*$' "$project_gitignore" > "$temp_gitignore" || true
    # Also remove commented .vscode entries
    grep -v -E '^[[:space:]]*#[[:space:]]*/?\.vscode/?[[:space:]]*$' "$temp_gitignore" > "${temp_gitignore}.2" || true
    mv "${temp_gitignore}.2" "$project_gitignore"
    rm -f "$temp_gitignore"

    local added_count=0

    while IFS= read -r line || [[ -n "$line" ]]; do

        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        if [ -z "$line" ]; then
            continue
        fi

        if ! grep -q -x -F "$line" "$project_gitignore" && ! grep -q -x -F "# $line" "$project_gitignore" && ! grep -q -x -F "#$line" "$project_gitignore"; then

            if [[ "$line" != /* ]] && grep -q -x -F "/$line" "$project_gitignore"; then
                continue
            fi

            if [[ "$line" == /* ]] && grep -q -x -F "${line#/}" "$project_gitignore"; then
                continue
            fi

            log "  Adding '$line' to .gitignore"

            if [ $added_count -eq 0 ]; then

                [ -s "$project_gitignore" ] && echo >>"$project_gitignore"

                echo "" >>"$project_gitignore" # Ensure separation
                echo "# --- Added by php-booster integration ---" >>"$project_gitignore"
                log "  Added header to .gitignore"
            fi
            echo "$line" >>"$project_gitignore"
            added_count=$((added_count + 1))
        fi
    done <"$booster_gitignore"

    if [ $added_count -gt 0 ]; then
        success ".gitignore updated with $added_count new entries."
    else
        log "No new entries needed for .gitignore."
    fi

    success ".vscode entries removed from project .gitignore (booster provides IDE settings)."
}

function cleanup_silent() {
    rm -rf "$BOOSTER_TARGET_DIR"
    rm -f composer.json.merged.tmp composer.json.merged.tmp.next hooks.yaml.tmp .ddev/config.yaml.tmp package.json.tmp # Clean up temp files
}

function cleanup() {
    log "Cleaning up temporary files..."
    rm -rf "$BOOSTER_TARGET_DIR"

    rm -f composer.json.merged.tmp composer.json.merged.tmp.next hooks.yaml.tmp .ddev/config.yaml.tmp package.json.tmp
    success "Temporary files cleaned up."
}

function update_nginx_config() {
    log "Updating nginx configuration..."
    local nginx_config=".ddev/nginx_full/nginx-site.conf"

    if [ ! -f "$nginx_config" ]; then
        log "Nginx config file '$nginx_config' not found. Skipping nginx update."
        return
    fi

    log "Found nginx config file, updating..."

    # Remove the DDEV-generated comment to track the file
    if grep -q "# ddev generated" "$nginx_config"; then
        log "  Removing DDEV generated comment to track the file..."
        sed -i.bak '/# ddev generated/d' "$nginx_config" || warn "Failed to remove DDEV generated comment."
    fi

    # Check if XDEBUG_TRIGGER is already configured
    if grep -q "fastcgi_param XDEBUG_TRIGGER" "$nginx_config"; then
        log "  XDEBUG_TRIGGER already configured in nginx config."
        return
    fi

    # Add XDEBUG_TRIGGER to the location ~ \.php$ block
    log "  Adding XDEBUG_TRIGGER environment variable to php location block..."

    # Create temporary content to insert
    local temp_insert_file="nginx_insert.tmp"
    cat >"$temp_insert_file" <<'EOF'
        # Always trigger Xdebug for web requests (CLI remains unaffected due to start_with_request=trigger)
        fastcgi_param XDEBUG_TRIGGER 1;
EOF

    # Use sed to add the content after the location ~ \.php$ line (cross-platform compatible)
    sed -i.bak '/location ~ \\\.php\$ {/r '"$temp_insert_file" "$nginx_config" || warn "Failed to add XDEBUG_TRIGGER to nginx config."

    # Remove #ddev generated comment if it exists
    sed -i.bak '/# ddev generated/d' "$nginx_config" || warn "Failed to remove DDEV generated comment."

    # Clean up temp file
    rm -f "$temp_insert_file"

    # Clean up backup file
    rm -f "$nginx_config.bak"

    success "Nginx configuration updated with XDEBUG_TRIGGER."
}

# Display help information
function show_help() {
    echo "PHP Booster Integration Script"
    echo ""
    echo "USAGE:"
    echo "  $0 [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  -I          Run in interactive mode (recommended for first-time setup)"
    echo "  -N          Non-interactive mode (skip all prompts, use defaults)"
    echo "  -v          Enable verbose logging"
    echo "  -c          Skip cleanup (preserve temporary files for debugging)"
    echo "  -i          Show version information and exit"
    echo "  -h          Show this help message and exit"
    echo ""
    echo "DESCRIPTION:"
    echo "  Integrates PHP Booster tooling into an existing PHP project."
    echo "  Supports both standard PHP projects and DDEV environments."
    echo ""
    echo "EXAMPLES:"
    echo "  $0              # Run integration with default settings"
    echo "  $0 -I           # Run in interactive mode (guided setup)"
    echo "  $0 -v           # Run with verbose output"
    echo "  $0 -i           # Show version information"
    echo ""
    echo "ENVIRONMENT VARIABLES:"
    echo "  BOOSTER_LOCAL_DEV=1     # Use local booster directory instead of GitHub"
    echo "  BOOSTER_LOCAL_PATH      # Path to local booster (default: ../booster)"
}

# Show version information and exit
function show_version_info_and_exit() {
    echo "PHP Booster Integration Script"
    echo ""

    # Try to get installed version first
    local installed_version
    installed_version=$(get_installed_version)

    if [ -n "$installed_version" ]; then
        echo "Installed version: $installed_version"
        if [ -f ".booster-version" ]; then
            echo "Installation details:"
            grep -E "^(INSTALLED_DATE|INTEGRATION_METHOD)=" ".booster-version" 2>/dev/null | sed 's/^/  /' || true
        fi
    else
        echo "No booster installation detected in current directory"
    fi

    echo ""
    # Try to get available version, but handle errors gracefully
    local available_version
    available_version=$(get_booster_version 2>/dev/null || echo "unknown")
    if [ "$available_version" = "unknown" ]; then
        echo "Available version: unknown (booster not downloaded yet)"
        echo "Run without -i to integrate and see available version"
    else
        echo "Available version (will be installed): $available_version"
    fi
    echo ""
    echo "To integrate or upgrade, run: $0"
    exit 0
}

# --- Main Execution ---

function main() {

    while getopts ":vchiIN" opt; do
        case $opt in
        v) VERBOSE=true ;;
        c) NO_CLEANUP=true ;;
        h) show_help; exit 0 ;;
        i) show_version_info_and_exit ;;
        I) INTERACTIVE_MODE=true ;;
        N) SKIP_INTERACTIVE=true ;;
        \?) error "Invalid option: -$OPTARG. Use -h for help." ;;
        :) error "Option -$OPTARG requires an argument." ;;
        esac
    done
    shift $((OPTIND - 1))

    log "Starting php-booster integration..."
    IS_DDEV_PROJECT=$(is_ddev_project)

    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        log "DDEV project detected."
    else
        log "Standard PHP project detected (no .ddev directory found)."
    fi

    if [ ! -f "composer.json" ] && [ ! -d ".git" ]; then
        warn "Script might not be running from the project root (composer.json or .git not found). Results may be unexpected."
    fi

    check_dependencies
    download_php_booster

    # --- Version Management ---
    local current_version
    current_version=$(get_booster_version)
    show_version_info "$current_version"

    # --- Interactive Mode ---
    if [ "$INTERACTIVE_MODE" = true ] && [ "$SKIP_INTERACTIVE" = false ]; then
        run_interactive_mode
    fi

    copy_files
    update_package_json
    update_readme
    update_gitignore
    update_tool_paths

    # Apply interactive configuration if mode was enabled
    if [ "$INTERACTIVE_MODE" = true ]; then
        apply_interactive_configuration
    fi

    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        log "Updating DDEV files..."

        local attempts=0
        local max_attempts=3
        while [ $attempts -lt $max_attempts ]; do
            if ddev start; then
                break
            else
                warn "ddev start failed. Retrying... ($((attempts + 1))/$max_attempts)"
                ((attempts++))
                sleep 5
            fi
        done
        update_ddev_files
        update_ddev_config
        update_nginx_config
        ddev restart
    fi

    add_code_quality_tools # Merges composer scripts & installs deps

    # --- Create Version Stamp ---
    create_version_stamp "$current_version"

    success "Integration process completed."

    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        success "Please run 'ddev restart' to apply the DDEV configuration changes."
    fi

    # Show post-installation summary in interactive mode
    if [ "$INTERACTIVE_MODE" = true ]; then
        show_post_installation_summary
    fi

    # Final cleanup
    if [ "$NO_CLEANUP" = true ]; then
        log "Skipping cleanup as per user request."
    else
        cleanup
    fi
}

# --- Script Entry Point ---
# Ensure script exits immediately if a command fails (safer execution)
set -e
# Ensure pipe failures are caught
set -o pipefail

# Run main function, passing all arguments
main "$@"

# Explicitly exit with success code
exit 0

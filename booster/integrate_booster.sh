#!/usr/bin/env bash

# This script is used to integrate the php-booster into your project (potentially DDEV)

# --- Configuration ---
BOOSTER_REPO_URL="https://github.com/TerrorSquad/php-booster.git"
BOOSTER_TARGET_DIR="php-booster"
BOOSTER_INTERNAL_PATH="${BOOSTER_TARGET_DIR}/booster"

# --- Local Development Mode ---
# Set BOOSTER_LOCAL_DEV=1 to use local booster directory instead of cloning from GitHub
# Set BOOSTER_LOCAL_PATH to specify the local booster directory path (default: ../booster)
BOOSTER_LOCAL_DEV="${BOOSTER_LOCAL_DEV:-0}"
BOOSTER_LOCAL_PATH="${BOOSTER_LOCAL_PATH:-../booster}"

# --- ANSI color codes ---
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

VERBOSE=false
NO_CLEANUP=false
IS_DDEV_PROJECT=0

# Set the memory limit for Composer to unlimited (can help with large dependency trees)
export COMPOSER_MEMORY_LIMIT=-1

# Set Symfony recipe auto-acceptance to avoid interactive prompts during composer require/update
# This automatically accepts all recipes from both main and contrib repositories
export SYMFONY_FLEX_RECIPES_AUTO_ACCEPT=1

# --- Version Management ---

# Extract version from booster composer.json
function get_booster_version() {
    local booster_composer="${BOOSTER_INTERNAL_PATH}/composer.json"
    if [ -f "$booster_composer" ]; then
        jq -r '.version // "unknown"' "$booster_composer"
    else
        echo "unknown"
    fi
}

# Get the currently installed booster version
function get_installed_version() {
    local version_file=".booster-version"
    if [ -f "$version_file" ]; then
        grep "^VERSION=" "$version_file" 2>/dev/null | cut -d'=' -f2 || echo ""
    else
        echo ""
    fi
}

# Create or update the version stamp file
function create_version_stamp() {
    local version="$1"
    local version_file=".booster-version"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    cat > "$version_file" << EOF
# PHP Booster Version Stamp
# This file tracks which booster version was integrated into this project
# Generated by integrate_booster.sh

VERSION=$version
INSTALLED_DATE=$timestamp
INTEGRATION_METHOD=script
EOF

    log "Created version stamp: $version (installed $timestamp)"
}

# Show version information and upgrade status
function show_version_info() {
    local current_version="$1"
    local installed_version
    installed_version=$(get_installed_version)

    if [ -n "$installed_version" ]; then
        echo -e "${GREEN}[INFO]${NC} Previous booster installation detected: $installed_version"
        echo -e "${GREEN}[INFO]${NC} Current booster version: $current_version"

        if [ "$installed_version" != "$current_version" ]; then
            echo -e "${YELLOW}[UPGRADE]${NC} This will upgrade your booster from $installed_version to $current_version"
        else
            echo -e "${GREEN}[INFO]${NC} Re-integrating same version (idempotent operation)"
        fi
    else
        echo -e "${GREEN}[INFO]${NC} Installing PHP Booster version: $current_version"
    fi
}

# --- Helper Functions ---

function log() {
    if [ "$VERBOSE" = true ]; then
        echo -e "${NC}[LOG] $1${NC}"
    fi
}

function warn() {
    echo -e "${YELLOW}[WARN] $1${NC}"
}

function error() {
    echo -e "${RED}[ERROR] $1${NC}" >&2
    # Clean up before exiting on error
    cleanup_silent
    exit 1
}

function success() {
    echo -e "${GREEN}[SUCCESS] $1${NC}"
}

# --- Dependency Checks ---

function check_dependencies() {
    log "Checking dependencies..."
    local missing_deps=()
    command -v jq >/dev/null 2>&1 || missing_deps+=("jq")
    command -v yq >/dev/null 2>&1 || missing_deps+=("yq") # Still needed for ddev config
    command -v curl >/dev/null 2>&1 || missing_deps+=("curl")
    command -v unzip >/dev/null 2>&1 || missing_deps+=("unzip")

    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        command -v ddev >/dev/null 2>&1 || missing_deps+=("ddev")
    else
        command -v composer >/dev/null 2>&1 || missing_deps+=("composer")
        command -v pnpm >/dev/null 2>&1 || missing_deps+=("pnpm")
    fi

    if [ ${#missing_deps[@]} -ne 0 ]; then
        error "Missing dependencies: ${missing_deps[*]}. Please install them."
    fi
    success "All dependencies are satisfied."
}

# --- Project Type Detection ---

function is_ddev_project() {
    if [ -d ".ddev" ]; then
        echo 1
    else
        echo 0
    fi
}

# --- Core Logic Functions ---

function download_php_booster() {
    if [ "$BOOSTER_LOCAL_DEV" = "1" ]; then
        log "Using local php-booster for development..."
        # Clean up previous attempts first
        rm -rf "$BOOSTER_TARGET_DIR" # Remove target dir if it exists

        # Check if local booster path exists
        if [ ! -d "$BOOSTER_LOCAL_PATH" ]; then
            error "Local booster directory not found at '$BOOSTER_LOCAL_PATH'. Set BOOSTER_LOCAL_PATH or ensure the directory exists."
        fi

        # Copy the local booster instead of cloning
        mkdir -p "$BOOSTER_TARGET_DIR"
        cp -R "$BOOSTER_LOCAL_PATH" "$BOOSTER_INTERNAL_PATH" || error "Failed to copy local booster directory."

        if [ ! -d "$BOOSTER_INTERNAL_PATH" ]; then
            error "Target directory '$BOOSTER_INTERNAL_PATH' not found after copy."
        fi

        success "Local php-booster copied successfully from '$BOOSTER_LOCAL_PATH'."
    else
        log "Cloning php-booster from $BOOSTER_REPO_URL..."
        # Clean up previous attempts first
        rm -rf "$BOOSTER_TARGET_DIR" # Remove target dir if it exists

        # Clone only the main branch and only the latest commit for speed
        git clone --depth 1 --branch main "$BOOSTER_REPO_URL" "$BOOSTER_TARGET_DIR" || error "Failed to clone booster repository."

        if [ ! -d "$BOOSTER_TARGET_DIR" ]; then
            error "Target directory '$BOOSTER_TARGET_DIR' not found after clone."
        fi

        if [ ! -d "$BOOSTER_INTERNAL_PATH" ]; then
            warn "The expected internal structure '$BOOSTER_INTERNAL_PATH' was not found within the cloned repository."
            error "Booster content directory '$BOOSTER_INTERNAL_PATH' not found."
        fi
        success "php-booster cloned successfully into '$BOOSTER_TARGET_DIR'."
    fi
}

function update_ddev_files() {
    log "Updating ddev files..."
    local booster_ddev_path="${BOOSTER_INTERNAL_PATH}/.ddev"
    local project_ddev_path=".ddev"

    if [ ! -d "$booster_ddev_path" ]; then
        warn "Booster DDEV directory '$booster_ddev_path' not found. Skipping DDEV file update."
        return
    fi

    # Define source -> destination mappings relative to .ddev dirs
    local ddev_subdirs=("commands" "php" "web-build")
    for subdir in "${ddev_subdirs[@]}"; do
        local src_path="${booster_ddev_path}/${subdir}"
        local dest_path="${project_ddev_path}/${subdir}"
        if [ -d "$src_path" ]; then
            log "  Copying '$src_path' to '$dest_path'..."
            # Use standard recursive copy -R, ensure destination parent exists
            mkdir -p "$dest_path"
            # Copy the source directory *into* the destination directory
            cp -R $src_path/. "$dest_path" || warn "Failed to copy '$src_path'. Check permissions."
        else
            log "  Booster DDEV subdirectory '$subdir' not found at '$src_path'. Skipping."
        fi
    done
    success "ddev files updated."
}

function update_ddev_config() {
    log "Updating ddev config using yq..."
    local project_config=".ddev/config.yaml"
    local booster_config="${BOOSTER_INTERNAL_PATH}/.ddev/config.yaml"
    local hooks_tmp="hooks.yaml.tmp"
    local merged_tmp=".ddev/config.yaml.tmp"

    if [ ! -f "$project_config" ]; then
        warn "Project DDEV config '$project_config' not found. Skipping update."
        return
    fi
    if [ ! -f "$booster_config" ]; then
        warn "Booster DDEV config '$booster_config' not found. Skipping update."
        return
    fi

    # 1. Extract hooks from booster config (handle potential errors)
    log "  Extracting hooks from booster config..."
    if ! yq '.hooks' "$booster_config" >"$hooks_tmp"; then
        warn "Failed to extract hooks using yq from '$booster_config'. Skipping hook merge."
        rm -f "$hooks_tmp"
    else
        # 2. Merge hooks into project config
        log "  Merging hooks into project config..."
        if ! yq eval-all 'select(fileIndex == 0) * {"hooks": select(fileIndex == 1)}' "$project_config" "$hooks_tmp" >"$merged_tmp"; then
            warn "Failed to merge hooks using yq. Original config preserved."
            rm -f "$hooks_tmp" "$merged_tmp"
            return # Stop ddev config update here if merge fails
        else
            # Replace project config with merged one if successful
            mv "$merged_tmp" "$project_config"
            log "  Hooks merged successfully."
        fi
        rm -f "$hooks_tmp"
    fi

    # 3. Ensure xdebug_enabled is true (operate on the potentially updated project_config)
    log "  Ensuring 'xdebug_enabled = true' using yq..."
    if ! yq eval '.xdebug_enabled = true' -i "$project_config"; then
        warn "Failed to set 'xdebug_enabled = true' using yq. Check '$project_config'."
    fi

    # 4. Copy nodejs_version key from booster config
    log "  Copying 'nodejs_version' from booster config..."
    nodejs_version=$(yq eval '.nodejs_version' "$booster_config")
    if ! yq eval ".nodejs_version = \"$nodejs_version\"" -i "$project_config"; then
        warn "Failed to copy 'nodejs_version' from booster config. Check '$project_config'."
    fi

    # 5. Ensure corepack_enable is true
    if ! yq eval '.corepack_enable = true' -i "$project_config"; then
        warn "Failed to set 'corepack_enable = true' using yq. Check '$project_config'."
    fi

    success "ddev config updated. Ensure the paths in the config are correct."
}

function copy_files() {
    log "Copying common files (excluding internal test helpers)..."

    # Copy simple top-level directories wholesale
    local top_level=(".github" ".vscode" ".phpstorm" ".editorconfig")
    for item in "${top_level[@]}"; do
        local src_path="${BOOSTER_INTERNAL_PATH}/${item}"
        if [ -e "$src_path" ]; then
            log "  Copying '$src_path' -> '$item'"
            cp -R "$src_path" . || warn "Failed to copy '$src_path'."
        else
            log "  Missing optional item '$item', skipping."
        fi
    done

    # Copy selected tool scripts instead of entire tools directory
    local tools_src="${BOOSTER_INTERNAL_PATH}/tools"
    if [ -d "$tools_src" ]; then
        mkdir -p tools/git-hooks/hooks
        # List of tool files to copy (public runtime helpers only)
        local tool_files=(
            "runner.sh"
            "commit-utils.py"
            "git-hooks"
        )
        for f in "${tool_files[@]}"; do
            if [ -f "$tools_src/$f" ]; then
                log "  Copying tool '$f'"
                cp "$tools_src/$f" tools/
                # Set execute permissions for shell scripts and Python files
                if [[ "$f" == *.sh ]] || [[ "$f" == *.py ]]; then
                    chmod +x "tools/$f"
                fi
            elif [ -d "$tools_src/$f" ]; then
                log "  Copying tool directory '$f'"
                cp -R "$tools_src/$f" tools/
                # Set execute permissions for shell scripts in the directory
                find "tools/$f" -name "*.sh" -exec chmod +x {} \;
                find "tools/$f" -name "*.bash" -exec chmod +x {} \;
            else
                warn "  Expected tool file missing: $f"
            fi
        done


    else
        warn "  Booster tools directory not found; skipping tools copy."
    fi

    # Copy validate-branch-name config (needed by hooks & scripts)
    local branch_cfg="${BOOSTER_INTERNAL_PATH}/validate-branch-name.config.cjs"
    if [ -f "$branch_cfg" ]; then
        cp "$branch_cfg" . || warn "Failed to copy validate-branch-name.config.cjs"
    else
        warn "validate-branch-name.config.cjs missing in booster."
    fi

    success "Common files copied (tools filtered to runtime essentials)."
}

function update_package_json() {
    log "Updating package.json..."
    local project_pkg="package.json"
    local booster_pkg="${BOOSTER_INTERNAL_PATH}/package.json"
    local booster_commitlint="${BOOSTER_INTERNAL_PATH}/commitlint.config.ts"
    local tmp_pkg="package.json.tmp"

    if [ ! -f "$booster_pkg" ]; then
        warn "Booster package.json '$booster_pkg' not found. Skipping update."
        return
    fi

    if [ ! -f "$project_pkg" ]; then
        log "'$project_pkg' not found. Copying from booster..."
        cp "$booster_pkg" "$project_pkg" || error "Failed to copy booster package.json."
        success "package.json copied from booster."
    else
        log "'$project_pkg' already exists. Merging scripts, devDependencies, and sections..."
        # Merge using jq: project + booster (booster overwrites simple keys, merges objects)
        # This merges top-level objects like scripts, devDependencies
        jq -s '
            .[0] as $proj | .[1] as $booster |
            $proj * {
                scripts: (($proj.scripts // {}) + ($booster.scripts // {})),
                devDependencies: (($proj.devDependencies // {}) + ($booster.devDependencies // {}))
            }
            ' "$project_pkg" "$booster_pkg" >"$tmp_pkg" || error "Failed to merge package.json using jq."

        mv "$tmp_pkg" "$project_pkg"
        success "package.json updated with merged scripts and devDependencies."
    fi

    # Copy commitlint config regardless
    if [ -f "$booster_commitlint" ]; then
        cp "$booster_commitlint" . || warn "Failed to copy commitlint config."
        success "commitlint.config.ts copied."
    else
        warn "Booster 'commitlint.config.ts' not found. Skipping copy."
    fi

    # Copy pnpm-workspace.yaml if it exists
    local booster_pnpm_workspace="${BOOSTER_INTERNAL_PATH}/pnpm-workspace.yaml"
    if [ -f "$booster_pnpm_workspace" ]; then
        cp "$booster_pnpm_workspace" . || warn "Failed to copy pnpm-workspace.yaml."
        success "pnpm-workspace.yaml copied."
    else
        warn "Booster 'pnpm-workspace.yaml' not found. Skipping copy."
    fi
}

# --- Updated merge_scripts Function ---
function merge_scripts() {
    local COMPOSER1="composer.json"                          # Project composer.json
    local COMPOSER2="${BOOSTER_INTERNAL_PATH}/composer.json" # Booster composer.json
    local OUTPUT="composer.json.merged.tmp"

    # Ensure jq is available
    command -v jq >/dev/null 2>&1 || error "jq is required but not installed."

    # Check if files exist
    [ ! -f "$COMPOSER1" ] && error "Project composer.json not found at '$COMPOSER1'"
    [ ! -f "$COMPOSER2" ] && error "Booster composer.json not found at '$COMPOSER2'"

    log "Merging scripts from '$COMPOSER2' into '$COMPOSER1'..."

    # Create a temporary copy to work on
    cp "$COMPOSER1" "$OUTPUT"

    # Get script keys from booster composer.json, handle null/missing scripts section
    # Use jq -e to check exit status if .scripts is null or not an object
    if ! jq -e '(.scripts // {}) | type == "object"' "$COMPOSER2" >/dev/null; then
        log "No valid 'scripts' object found in booster composer.json. Nothing to merge."
        rm "$OUTPUT" # Clean up temp file
        return 0
    fi
    local booster_keys
    booster_keys=$(jq -r '.scripts | keys_unsorted | .[]' "$COMPOSER2")

    # Iterate over each script key from the booster
    echo "$booster_keys" | while IFS= read -r key; do
        log "  Processing script key: $key"

        # Get values and types using jq
    local proj_script_json
    proj_script_json=$(jq --arg key "$key" '(.scripts // {})[$key]' "$OUTPUT")
    local booster_script_json
    booster_script_json=$(jq --arg key "$key" '.scripts[$key]' "$COMPOSER2") # Assumes .scripts exists from check above
    local proj_type
    proj_type=$(jq -r 'type' <<<"$proj_script_json")
    local booster_type
    booster_type=$(jq -r 'type' <<<"$booster_script_json")

        log "    Project type: $proj_type, Booster type: $booster_type"

        local merged_script_json

        if [ "$proj_type" == "null" ]; then
            # Script only exists in booster, add it
            log "    Adding script from booster."
            merged_script_json="$booster_script_json"
        else
            # Script exists in both project and booster, merge based on type
            if [ "$proj_type" == "string" ] && [ "$booster_type" == "string" ]; then
                if [ "$proj_script_json" == "$booster_script_json" ]; then
                    log "    Scripts are identical strings, keeping project version."
                    merged_script_json="$proj_script_json"
                else
                    log "    Scripts are different strings, merging into unique array."
                    # Ensure output is valid JSON array
                    merged_script_json=$(jq -n --argjson p "$proj_script_json" --argjson b "$booster_script_json" '[$p, $b] | unique')
                fi
            elif [ "$proj_type" == "array" ] && [ "$booster_type" == "array" ]; then
                log "    Both scripts are arrays, merging uniquely."
                merged_script_json=$(jq -n --argjson p "$proj_script_json" --argjson b "$booster_script_json" '($p + $b) | unique')
            elif [ "$proj_type" == "string" ] && [ "$booster_type" == "array" ]; then
                log "    Project is string, booster is array. Merging uniquely."
                merged_script_json=$(jq -n --argjson p "$proj_script_json" --argjson b "$booster_script_json" '([$p] + $b) | unique')
            elif [ "$proj_type" == "array" ] && [ "$booster_type" == "string" ]; then
                log "    Project is array, booster is string. Merging uniquely."
                merged_script_json=$(jq -n --argjson p "$proj_script_json" --argjson b "$booster_script_json" '($p + [$b]) | unique')
            else
                # Handle other mismatches (e.g., object vs string) - prefer booster? Or keep project? Let's prefer booster.
                log "    Type mismatch ($proj_type vs $booster_type). Using booster version."
                merged_script_json="$booster_script_json"
            fi
        fi

        # Update the temporary composer file with the merged script
        # Ensure .scripts object exists before assigning
        local temp_next="$OUTPUT.next"
        jq --arg key "$key" --argjson value "$merged_script_json" \
            'if (.scripts | type) != "object" then .scripts = {} else . end | .scripts[$key] = $value' \
            "$OUTPUT" >"$temp_next" || {
            error "jq update failed for key '$key'"
            rm "$temp_next" "$OUTPUT"
            return 1
        } # Exit loop on jq error
        mv "$temp_next" "$OUTPUT"

    done || error "Failed during script merging loop." # Catch errors from the while loop subshell

    # Replace the original composer.json with the merged version
    mv "$OUTPUT" "$COMPOSER1"
    success "Scripts merged idempotently into $COMPOSER1."
}
# --- Function to Update Tool Paths Dynamically ---
function update_tool_paths() {
    # --- Copy Documentation Directory ---
    local booster_doc_path="${BOOSTER_INTERNAL_PATH}/documentation"
    if [ -d "$booster_doc_path" ]; then
        log "  Copying '$booster_doc_path' to 'documentation'..."
        # Use standard recursive copy -R
        cp -R "$booster_doc_path/." "documentation" || warn "Failed to copy documentation directory."
    else
        log "  Booster documentation directory not found. Skipping."
    fi

    # --- Copy Config Files ---
    local cq_files=("rector.php" "phpstan.neon.dist" "ecs.php" "psalm.xml")
    for file in "${cq_files[@]}"; do
        local src_path="${BOOSTER_INTERNAL_PATH}/${file}"
        if [ -f "$src_path" ]; then
            cp "$src_path" . || warn "Failed to copy '$src_path'."
        else
            log "  Booster config '$file' not found. Skipping."
        fi
    done

    success "Code quality tool configs and documentation copied."

    log "Dynamically updating paths in tool configuration files using temp files and sed..."
    local php_dirs_file="php_dirs.txt"
    local return_code=0 # Track overall success/failure

    # 1. Find directories containing .php files and save to php_dirs.txt
    log "  Searching for directories containing PHP files (excluding vendor, .git, node_modules, etc.)..."
    find . -type f \
        -name "*.php" \
        -not -path "./vendor/*" \
        -not -path "./node_modules/*" \
        -not -path "./php-booster/*" \
        -not -path "./.ddev/*" \
        -exec dirname {} \; | sort -u | grep -v ^.$ | cut -d '/' -f2 | sort -u >"$php_dirs_file" || {
        warn "find command failed or produced unexpected output while searching for PHP directories."
        # Create empty file if find failed, to avoid errors later
        touch "$php_dirs_file"
    }

    if [ ! -s "$php_dirs_file" ]; then
        warn "No subdirectories containing PHP files found (excluding vendor, hidden dirs, etc.). Placeholders will be removed from tool configurations."
    else
        log "  Found PHP directories listed in '$php_dirs_file'."
    fi

    # --- Define helper for sed replacement ---
    # Usage: replace_placeholder "config_file" "placeholder_regex" "formatted_dirs_file"
    function replace_placeholder() {
        local config_file="$1"
        local placeholder_regex="$2"
        local formatted_dirs_file="$3"
        local tmp_config_file="${config_file}.tmp"

        if [ ! -f "$config_file" ]; then
            log "    File '$config_file' not found. Skipping."
            return 0
        fi

        log "    Processing '$config_file'..."
        # Use process substitution <(...) if available and preferred, otherwise use temp file
        # Using temp file for broader compatibility

        # Create the new file by reading the formatted dirs where the placeholder is found
        # Use -n to suppress default output, p to print non-matching lines, r to read on match
        # This requires two passes or complex scripting. Let's use the requested r/d approach.

        # Pass 1: Read the formatted dirs file after the placeholder line
        sed -e "$placeholder_regex r $formatted_dirs_file" "$config_file" >"$tmp_config_file" || {
            warn "sed 'r' command failed for '$config_file'."
            rm -f "$tmp_config_file"
            return 1
        }

        # Pass 2: Delete the placeholder line from the temp file, overwrite original
        sed -i.bak -e "$placeholder_regex d" "$tmp_config_file" || {
            warn "sed 'd' command failed for '$tmp_config_file'."
            rm -f "$tmp_config_file"
            # Restore original from backup if it exists
            [ -f "${config_file}.bak" ] && mv "${config_file}.bak" "$config_file"
            return 1
        }

        mv "$tmp_config_file" "$config_file"
        rm -f $config_file.tmp.bak

        return 0
    }

    # --- Process Rector PHP file ---
    local rector_file="rector.php"
    local rector_dirs_file="rector_dirs.txt"
    local rector_placeholder_regex="/^[[:space:]]*__DIR__ \. '\/DIRECTORY',[[:space:]]*$/"
    # Create formatted dirs file
    rm -f "$rector_dirs_file" && touch "$rector_dirs_file"
    if [ -s "$php_dirs_file" ]; then # Only loop if dirs were found
        while IFS= read -r dir; do
            printf "        __DIR__ . '/%s',\n" "$dir" >>"$rector_dirs_file"
        done <"$php_dirs_file"
    fi

    replace_placeholder "$rector_file" "$rector_placeholder_regex" "$rector_dirs_file" || return_code=1
    rm -f "$rector_dirs_file" # Clean up

    # --- Process ECS PHP file ---
    local ecs_file="ecs.php"
    local ecs_dirs_file="ecs_dirs.txt"
    local ecs_placeholder_regex="/^[[:space:]]*__DIR__ \. '\/DIRECTORY',[[:space:]]*$/"

    rm -f "$ecs_dirs_file" && touch "$ecs_dirs_file"
    if [ -s "$php_dirs_file" ]; then
        while IFS= read -r dir; do
            printf "        __DIR__ . '/%s',\n" "$dir" >>"$ecs_dirs_file"
        done <"$php_dirs_file"
    fi

    replace_placeholder "$ecs_file" "$ecs_placeholder_regex" "$ecs_dirs_file" || return_code=1
    rm -f "$ecs_dirs_file" # Clean up

    # --- Process Psalm XML file ---
    local psalm_file="psalm.xml"
    local psalm_dirs_file="psalm_dirs.txt"
    local psalm_placeholder_regex='/^[[:space:]]*<directory name="DIRECTORY" \/>[[:space:]]*$/'

    rm -f "$psalm_dirs_file" && touch "$psalm_dirs_file"
    if [ -s "$php_dirs_file" ]; then
        while IFS= read -r dir; do
            # Basic XML escaping for dir name (only & and < are strictly needed here, but > and " are good practice)
            local escaped_dir
            escaped_dir=$(echo "$dir" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g' -e 's/"/\&quot;/g')
            printf '        <directory name="%s" />\n' "$escaped_dir" >>"$psalm_dirs_file"
        done <"$php_dirs_file"
    fi

    replace_placeholder "$psalm_file" "$psalm_placeholder_regex" "$psalm_dirs_file" || return_code=1
    rm -f "$psalm_dirs_file" # Clean up

    # --- Process PHPStan NEON file ---
    local phpstan_file="phpstan.neon.dist"
    local phpstan_dirs_file="phpstan_dirs.txt"
    local phpstan_placeholder_regex='/^[[:space:]]*-[[:space:]]*DIRECTORY[[:space:]]*$/'

    rm -f "$phpstan_dirs_file" && touch "$phpstan_dirs_file"
    if [ -s "$php_dirs_file" ]; then
        while IFS= read -r dir; do
            printf '    - %s\n' "$dir" >>"$phpstan_dirs_file"
        done <"$php_dirs_file"
    fi

    replace_placeholder "$phpstan_file" "$phpstan_placeholder_regex" "$phpstan_dirs_file" || return_code=1
    rm -f "$phpstan_dirs_file" # Clean up

    # --- Final Cleanup and Status ---
    rm -f "$php_dirs_file"

    if [ $return_code -eq 0 ]; then
        success "Tool configuration paths updated dynamically based on found PHP directories."
        return 0
    else
        warn "Errors occurred while updating tool configuration paths. Check logs."
        return 1
    fi
}

function add_code_quality_tools() {
    log "Adding code quality tools..."
    local project_composer="composer.json"
    local booster_composer="${BOOSTER_INTERNAL_PATH}/composer.json"

    # --- Update composer.json ---
    log "Updating composer.json..."
    if [ ! -f "$project_composer" ]; then
        warn "'$project_composer' not found. Cannot merge scripts or add dependencies. Consider copying booster composer.json first."
        return
    fi
    if [ ! -f "$booster_composer" ]; then
        warn "Booster composer.json '$booster_composer' not found. Skipping composer update."
        return
    fi

    merge_scripts

    # --- Install Composer Dependencies ---
    local composer_cmd
    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        composer_cmd=(ddev composer)
    else
        composer_cmd=(composer)
    fi

    # Helper function to check if a package is already declared in composer.json
    function is_package_present() {
        local package="$1"
        local section="$2"  # "require" or "require-dev"

        log "    Checking if package '$package' is present in section '$section'..."

        # Check if package is declared in the appropriate section of composer.json
        if [ "$section" = "require" ]; then
            if jq -e --arg pkg "$package" '.require[$pkg] != null' "$project_composer" >/dev/null 2>&1; then
                log "    Package '$package' found in require section."
                return 0
            else
                log "    Package '$package' NOT found in require section."
                return 1
            fi
        elif [ "$section" = "require-dev" ]; then
            if jq -e --arg pkg "$package" '.["require-dev"][$pkg] != null' "$project_composer" >/dev/null 2>&1; then
                log "    Package '$package' found in require-dev section."
                return 0
            else
                log "    Package '$package' NOT found in require-dev section."
                return 1
            fi
        else
            # If no section specified, check both require and require-dev
            if jq -e --arg pkg "$package" '(.require[$pkg] != null) or (.["require-dev"][$pkg] != null)' "$project_composer" >/dev/null 2>&1; then
                log "    Package '$package' found in either require or require-dev section."
                return 0
            else
                log "    Package '$package' NOT found in either section."
                return 1
            fi
        fi
    }

    # Process production dependencies
    if jq -e '.require | type == "object"' "$booster_composer" >/dev/null; then
    local prod_deps
    prod_deps=$(jq -r '.require | keys_unsorted | .[]' "$booster_composer")
        local missing_prod_deps=()

        if [ -n "$prod_deps" ]; then
            log "Checking production dependencies..."
            while IFS= read -r dep; do
                if ! is_package_present "$dep" "require"; then
                    log "  Missing production dependency: $dep"
                    missing_prod_deps+=("$dep")
                else
                    log "  Production dependency already present: $dep"
                fi
            done <<<"$prod_deps"

            if [ ${#missing_prod_deps[@]} -gt 0 ]; then
                log "Adding missing composer 'require' dependencies from booster..."
                "${composer_cmd[@]}" require --no-scripts "${missing_prod_deps[@]}" || warn "Failed to add some production dependencies (require step)."
            else
                log "All production dependencies are already present."
            fi
        else
            log "No production dependencies found in booster composer.json 'require' section."
        fi
    else
        log "No 'require' object found in booster composer.json."
    fi

    # Process development dependencies
    if jq -e '.["require-dev"] | type == "object"' "$booster_composer" >/dev/null; then
    local dev_deps
    dev_deps=$(jq -r '.["require-dev"] | keys_unsorted | .[]' "$booster_composer")
        local missing_dev_deps=()

        log "Booster require-dev packages found: $(echo "$dev_deps" | tr '\n' ' ')"

        if [ -n "$dev_deps" ]; then
            log "Checking development dependencies..."
            while IFS= read -r dep; do
                if ! is_package_present "$dep" "require-dev"; then
                    log "  Missing dev dependency: $dep"
                    missing_dev_deps+=("$dep")
                else
                    log "  Dev dependency already present: $dep"
                fi
            done <<<"$dev_deps"

            log "Missing dev dependencies to install: ${missing_dev_deps[*]}"

            if [ ${#missing_dev_deps[@]} -gt 0 ]; then
                log "Adding missing composer 'require-dev' dependencies from booster..."
                "${composer_cmd[@]}" require --dev "${missing_dev_deps[@]}" || warn "Failed to install/update some dev dependencies. Check composer output."
            else
                log "All development dependencies are already present."
            fi
        else
            log "No development dependencies found in booster composer.json 'require-dev' section."
        fi
    else
        log "No 'require-dev' object found in booster composer.json."
    fi

    success "composer.json updated with merged scripts and new dependencies."
}

function update_readme() {
    log "Updating README.md..."
    local project_readme="README.md"
    local booster_snippet="${BOOSTER_INTERNAL_PATH}/README_SNIPPET.md"

    if [ -f "$project_readme" ]; then
        log "'$project_readme' already exists. Skipping creation."
    else
        if [ -f "$booster_snippet" ]; then
            warn "'$project_readme' not found. Creating new README.md from booster snippet..."
            cp "$booster_snippet" "$project_readme" || error "Failed to copy README snippet."
            success "New README.md created with content from '$booster_snippet'."
        else
            warn "'$project_readme' not found, and booster snippet '$booster_snippet' also not found. Skipping."
        fi
    fi
}

function update_gitignore() {
    log "Updating .gitignore..."
    local project_gitignore=".gitignore"
    local booster_gitignore="${BOOSTER_INTERNAL_PATH}/.gitignore"

    if [ ! -f "$booster_gitignore" ]; then
        warn "Booster .gitignore '$booster_gitignore' not found. Skipping update."
        return
    fi

    touch "$project_gitignore"

    local added_count=0

    while IFS= read -r line || [[ -n "$line" ]]; do

        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        if [ -z "$line" ]; then
            continue
        fi

        if ! grep -q -x -F "$line" "$project_gitignore" && ! grep -q -x -F "# $line" "$project_gitignore" && ! grep -q -x -F "#$line" "$project_gitignore"; then

            if [[ "$line" != /* ]] && grep -q -x -F "/$line" "$project_gitignore"; then
                continue
            fi

            if [[ "$line" == /* ]] && grep -q -x -F "${line#/}" "$project_gitignore"; then
                continue
            fi

            log "  Adding '$line' to .gitignore"

            if [ $added_count -eq 0 ]; then

                [ -s "$project_gitignore" ] && echo >>"$project_gitignore"

                echo "" >>"$project_gitignore" # Ensure separation
                echo "# --- Added by php-booster integration ---" >>"$project_gitignore"
                log "  Added header to .gitignore"
            fi
            echo "$line" >>"$project_gitignore"
            added_count=$((added_count + 1))
        fi
    done <"$booster_gitignore"

    if [ $added_count -gt 0 ]; then
        success ".gitignore updated with $added_count new entries."
    else
        log "No new entries needed for .gitignore."
    fi
}

function cleanup_silent() {
    rm -rf "$BOOSTER_TARGET_DIR"
    rm -f composer.json.merged.tmp composer.json.merged.tmp.next hooks.yaml.tmp .ddev/config.yaml.tmp package.json.tmp # Clean up temp files
}

function cleanup() {
    log "Cleaning up temporary files..."
    rm -rf "$BOOSTER_TARGET_DIR"

    rm -f composer.json.merged.tmp composer.json.merged.tmp.next hooks.yaml.tmp .ddev/config.yaml.tmp package.json.tmp
    success "Temporary files cleaned up."
}

function update_nginx_config() {
    log "Updating nginx configuration..."
    local nginx_config=".ddev/nginx_full/nginx-site.conf"

    if [ ! -f "$nginx_config" ]; then
        log "Nginx config file '$nginx_config' not found. Skipping nginx update."
        return
    fi

    log "Found nginx config file, updating..."

    # Remove the DDEV-generated comment to track the file
    if grep -q "# ddev generated" "$nginx_config"; then
        log "  Removing DDEV generated comment to track the file..."
        sed -i.bak '/# ddev generated/d' "$nginx_config" || warn "Failed to remove DDEV generated comment."
    fi

    # Check if XDEBUG_TRIGGER is already configured
    if grep -q "fastcgi_param XDEBUG_TRIGGER" "$nginx_config"; then
        log "  XDEBUG_TRIGGER already configured in nginx config."
        return
    fi

    # Add XDEBUG_TRIGGER to the location ~ \.php$ block
    log "  Adding XDEBUG_TRIGGER environment variable to php location block..."

    # Create temporary content to insert
    local temp_insert_file="nginx_insert.tmp"
    cat >"$temp_insert_file" <<'EOF'
        # Always trigger Xdebug for web requests (CLI remains unaffected due to start_with_request=trigger)
        fastcgi_param XDEBUG_TRIGGER 1;
EOF

    # Use sed to add the content after the location ~ \.php$ line (cross-platform compatible)
    sed -i.bak '/location ~ \\\.php\$ {/r '"$temp_insert_file" "$nginx_config" || warn "Failed to add XDEBUG_TRIGGER to nginx config."

    # Remove #ddev generated comment if it exists
    sed -i.bak '/# ddev generated/d' "$nginx_config" || warn "Failed to remove DDEV generated comment."

    # Clean up temp file
    rm -f "$temp_insert_file"

    # Clean up backup file
    rm -f "$nginx_config.bak"

    success "Nginx configuration updated with XDEBUG_TRIGGER."
}

# Display help information
function show_help() {
    echo "PHP Booster Integration Script"
    echo ""
    echo "USAGE:"
    echo "  $0 [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  -v          Enable verbose logging"
    echo "  -c          Skip cleanup (preserve temporary files for debugging)"
    echo "  -i          Show version information and exit"
    echo "  -h          Show this help message and exit"
    echo ""
    echo "DESCRIPTION:"
    echo "  Integrates PHP Booster tooling into an existing PHP project."
    echo "  Supports both standard PHP projects and DDEV environments."
    echo ""
    echo "EXAMPLES:"
    echo "  $0              # Run integration with default settings"
    echo "  $0 -v           # Run with verbose output"
    echo "  $0 -i           # Show version information"
    echo ""
    echo "ENVIRONMENT VARIABLES:"
    echo "  BOOSTER_LOCAL_DEV=1     # Use local booster directory instead of GitHub"
    echo "  BOOSTER_LOCAL_PATH      # Path to local booster (default: ../booster)"
}

# Show version information and exit
function show_version_info_and_exit() {
    echo "PHP Booster Integration Script"
    echo ""

    # Try to get installed version first
    local installed_version
    installed_version=$(get_installed_version)

    if [ -n "$installed_version" ]; then
        echo "Installed version: $installed_version"
        if [ -f ".booster-version" ]; then
            echo "Installation details:"
            grep -E "^(INSTALLED_DATE|INTEGRATION_METHOD)=" ".booster-version" 2>/dev/null | sed 's/^/  /' || true
        fi
    else
        echo "No booster installation detected in current directory"
    fi

    echo ""
    # Try to get available version, but handle errors gracefully
    local available_version
    available_version=$(get_booster_version 2>/dev/null || echo "unknown")
    if [ "$available_version" = "unknown" ]; then
        echo "Available version: unknown (booster not downloaded yet)"
        echo "Run without -i to integrate and see available version"
    else
        echo "Available version (will be installed): $available_version"
    fi
    echo ""
    echo "To integrate or upgrade, run: $0"
    exit 0
}

# --- Main Execution ---

function main() {

    while getopts ":vchi" opt; do
        case $opt in
        v) VERBOSE=true ;;
        c) NO_CLEANUP=true ;;
        h) show_help; exit 0 ;;
        i) show_version_info_and_exit ;;
        \?) error "Invalid option: -$OPTARG. Use -h for help." ;;
        :) error "Option -$OPTARG requires an argument." ;;
        esac
    done
    shift $((OPTIND - 1))

    log "Starting php-booster integration..."
    IS_DDEV_PROJECT=$(is_ddev_project)

    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        log "DDEV project detected."
    else
        log "Standard PHP project detected (no .ddev directory found)."
    fi

    if [ ! -f "composer.json" ] && [ ! -d ".git" ]; then
        warn "Script might not be running from the project root (composer.json or .git not found). Results may be unexpected."
    fi

    check_dependencies
    download_php_booster

    # --- Version Management ---
    local current_version
    current_version=$(get_booster_version)
    show_version_info "$current_version"

    copy_files
    update_package_json
    update_readme
    update_gitignore
    update_tool_paths

    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        log "Updating DDEV files..."

        local attempts=0
        local max_attempts=3
        while [ $attempts -lt $max_attempts ]; do
            if ddev start; then
                break
            else
                warn "ddev start failed. Retrying... ($((attempts + 1))/$max_attempts)"
                ((attempts++))
                sleep 5
            fi
        done
        update_ddev_files
        update_ddev_config
        update_nginx_config
        ddev restart
    fi

    add_code_quality_tools # Merges composer scripts & installs deps

    # --- Create Version Stamp ---
    create_version_stamp "$current_version"

    success "Integration process completed."

    if [ $IS_DDEV_PROJECT -eq 1 ]; then
        success "Please run 'ddev restart' to apply the DDEV configuration changes."
    fi

    # Final cleanup
    if [ "$NO_CLEANUP" = true ]; then
        log "Skipping cleanup as per user request."
    else
        cleanup
    fi
}

# --- Script Entry Point ---
# Ensure script exits immediately if a command fails (safer execution)
set -e
# Ensure pipe failures are caught
set -o pipefail

# Run main function, passing all arguments
main "$@"

# Explicitly exit with success code
exit 0
